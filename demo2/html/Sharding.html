<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">Sharding</h1>                                <a href="https://translate.gorm.io/project/go-gorm/zh-CN" target="_blank" rel="noopener" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><p>Sharding 是一个高性能的 Gorm 分表中间件。它基于 Conn 层做 SQL 拦截、AST 解析、分表路由、自增主键填充，带来的额外开销极小。对开发者友好、透明，使用上与普通 SQL、Gorm 查询无差别，只需要额外注意一下分表键条件。 为您提供高性能的数据库访问。</p><p><a href="https://github.com/go-gorm/sharding" target="_blank" rel="noopener">https://github.com/go-gorm/sharding</a></p><h2 id="功能特点" class="article-heading"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点<a class="article-anchor" href="#功能特点" aria-hidden="true"></a></h2><ul><li>非侵入式设计， 加载插件，指定配置，既可实现分表。</li><li>轻快， 非基于网络层的中间件，像 Go 一样快</li><li>支持多种数据库。 PostgreSQL 已通过测试，MySQL 和 SQLite 也在路上。</li><li>多种主键生成方式支持（Snowflake, PostgreSQL Sequence, 以及自定义支持）Snowflake 支持从主键中确定分表键。</li></ul><h2 id="使用说明" class="article-heading"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明<a class="article-anchor" href="#使用说明" aria-hidden="true"></a></h2><p>配置 Sharding 中间件，为需要分表的业务表定义他们分表的规则。 查看 <a href="https://pkg.go.dev/github.com/go-gorm/sharding" target="_blank" rel="noopener">Godoc</a> 获取配置详情。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"gorm.io/driver/postgres"</span></span><br><span class="line">    <span class="string">"gorm.io/gorm"</span></span><br><span class="line">    <span class="string">"gorm.io/sharding"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">dsn := <span class="string">"postgres://localhost:5432/sharding-db?sslmode=disable"</span></span><br><span class="line">db, err := gorm.Open(postgres.New(postgres.Config{DSN: dsn}))</span><br><span class="line"></span><br><span class="line">db.Use(sharding.Register(sharding.Config{</span><br><span class="line">    ShardingKey:         <span class="string">"user_id"</span>,</span><br><span class="line">    NumberOfShards:      <span class="number">64</span>,</span><br><span class="line">    PrimaryKeyGenerator: sharding.PKSnowflake,</span><br><span class="line">}, <span class="string">"orders"</span>).Register(sharding.Config{</span><br><span class="line">    ShardingKey:         <span class="string">"user_id"</span>,</span><br><span class="line">    NumberOfShards:      <span class="number">256</span>,</span><br><span class="line">    PrimaryKeyGenerator: sharding.PKSnowflake,</span><br><span class="line">    <span class="comment">// This case for show up give notifications, audit_logs table use same sharding rule.</span></span><br><span class="line">}, Notification{}, AuditLog{}))</span><br></pre></td></tr></tbody></table></figure><p>依然保持原来的方式使用 db 来查询数据库。 你只需要注意在 CURD 动作的时候，<code>明确知道 Sharding Key</code> 对应的分表，查询条件带 Sharding Key，以确保 Sharding 能理解数据需要对应到哪一个子表。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// GORM 创建示例，这会插入到 orders_02 表</span></span><br><span class="line">db.Create(&amp;Order{UserID: <span class="number">2</span>})</span><br><span class="line"><span class="comment">// sql: INSERT INTO orders_2 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 SQL 插入示例，这会插入到 orders_03 表</span></span><br><span class="line">db.Exec(<span class="string">"INSERT INTO orders(user_id) VALUES(?)"</span>, <span class="keyword">int64</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这会抛出 ErrMissingShardingKey 错误，因此此处没有提供 sharding key</span></span><br><span class="line">db.Create(&amp;Order{Amount: <span class="number">10</span>, ProductID: <span class="number">100</span>})</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find 方法，这会检索 order_02 表</span></span><br><span class="line"><span class="keyword">var</span> orders []Order</span><br><span class="line">db.Model(&amp;Order{}).Where(<span class="string">"user_id"</span>, <span class="keyword">int64</span>(<span class="number">2</span>)).Find(&amp;orders)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, orders)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 SQL 也是支持的</span></span><br><span class="line">db.Raw(<span class="string">"SELECT * FROM orders WHERE user_id = ?"</span>, <span class="keyword">int64</span>(<span class="number">3</span>)).Scan(&amp;orders)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, orders)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这会抛出 ErrMissingShardingKey 错误，因为 WHERE 条件没有包含 sharding key</span></span><br><span class="line">err = db.Model(&amp;Order{}).Where(<span class="string">"product_id"</span>, <span class="string">"1"</span>).Find(&amp;orders).Error</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 和 Delete 方法与创建、查询类似</span></span><br><span class="line">db.Exec(<span class="string">"UPDATE orders SET product_id = ? WHERE user_id = ?"</span>, <span class="number">2</span>, <span class="keyword">int64</span>(<span class="number">3</span>))</span><br><span class="line">err = db.Exec(<span class="string">"DELETE FROM orders WHERE product_id = 3"</span>).Error</span><br><span class="line">fmt.Println(err) <span class="comment">// ErrMissingShardingKey</span></span><br></pre></td></tr></tbody></table></figure><p>完整示例演示 <a href="https://github.com/go-gorm/sharding/tree/main/examples" target="_blank" rel="noopener">Example</a>。</p></body></html>              </div>